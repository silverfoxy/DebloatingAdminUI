<?php
/* 
 * Generated by CRUDigniter v3.2 
 * www.crudigniter.com
 */

use PhpParser\NodeTraverser;
use PhpParser\Error;
use PhpParser\ParserFactory;
use PhpParser\Node;
use PhpParser\NodeVisitorAbstract;

class Import_coverage extends CI_Controller{
    function __construct()
    {
        parent::__construct();
        $this->load->model('Report_model');
    }

    /*
     * Import text-based code coverage logs
     */
    function import()
    {   
        if(isset($_POST) && count($_POST) > 0)     
        {   
            $config['upload_path'] = '/var/www/html/admin/uploads/';
            $config['allowed_types'] = 'txt';
            // $config['max_size'] = 100000;
            $config['file_name'] = tempnam('', '');
            $this->load->library('upload', $config);
            if (!$this->upload->do_upload('file'))
            {
                show_error($this->upload->display_errors());  
            }
            else
            {
                try {
                    $fk_software_version_id = $this->input->post('fk_version_id');
                    $original_path_prefix = $this->input->post('original_path_prefix') ?? '';
                    $new_path_prefix = $this->input->post('new_path_prefix') ?? '';
                    $test_name =  $this->input->post('test_name');
                    if ($this->input->post('file_type') === 'line_coverage') {
                        $results = $this->parse_and_import_file($fk_software_version_id, $test_name, $this->upload->data('full_path'), $original_path_prefix, $new_path_prefix, $data);
                    }
                    elseif ($this->input->post('file_type') === 'function_coverage') {
                        $results = $this->parse_and_import_functioncoverage($fk_software_version_id, $test_name, $this->upload->data('full_path'), $original_path_prefix, $new_path_prefix, $data);
                    }
                    $data['success_messages'][] = 'Coverage information ('.$test_name.') imported successfully.';
                    $data['success_messages'][] = 'Imported '.$results['added_files'].' files.';
                    $data['success_messages'][] = 'Imported '.$results['added_lines'].' lines.';
                    if ($results['skipped_lines'] > 0) {
                        $data['warning_messages'][] = 'Skipped '.$results['skipped_lines'].' lines.';
                    }
                } catch (\Exception $e) {
                    $data['error_messages'][] = $e->getMessage();
                }
                finally {
                    // Delete the temporary file
                    unlink($this->upload->data('full_path'));
                }
                // Return all tests within a category
                $this->load->model('Test_model');
                $data['tests'] = $this->Test_model->get_all_test_groups();
                $data['_view'] = 'report/groups';
                $this->load->view('layouts/main',$data);
            }

        }
        else
        {         
            $this->load->model('Software_version_model');
            $data['all_software_version'] = $this->Software_version_model->get_all_software_version(); 
            $data['_view'] = 'import_coverage/import';
            $this->load->view('layouts/main',$data);
        }
    }  

    function replace_first($find, $replace, $subject) {
        // stolen from the comments at PHP.net/str_replace
        // Splits $subject into an array of 2 items by $find,
        // and then joins the array with $replace
        return implode($replace, explode($find, $subject, 2));
    }

    protected function parse_and_import_file($fk_software_version_id, $test_name, $file_path, $original_prefix, $new_prefix, &$data) {
        $skipped_lines = 0;
        $file_coverage = [];
        if ($fh = fopen($file_path, 'r')) {
            while (!feof($fh)) {
                $line = fgets($fh);
                try {
                    if (strpos($line, ':') !== false) {
                        $file_entry = explode(': ', $line);
                        $file_name = $file_entry[0];
                        $covered_lines = trim($file_entry[1]);
                        if (strlen($line) >= strlen($original_prefix)) {
                            if (substr($line, 0, strlen($original_prefix)) === $original_prefix) {
                                $file_name = $this->replace_first($original_prefix, $new_prefix, $file_name);
                            }
                        }
                        $covered_lines_array = explode('-', $covered_lines);

                        for ($i=$covered_lines_array[0]; $i <= $covered_lines_array[1]; $i++) {
                            $file_coverage[$file_name][$i] = true;
                        }
                    }
                }
                catch (\Exception $e) {
                    $data['error_messages'][] = $e->getMessage();
                    $skipped_lines++;
                }
            }
            fclose($fh);
        }
        $info = $this->add_coverage_to_db($fk_software_version_id, $test_name, $file_coverage);
        $info['skipped_lines'] = $skipped_lines;
        return $info;
    }

    protected function parse_and_import_functioncoverage($fk_software_version_id, $test_name, $file_path, $original_prefix, $new_prefix, &$data) {
        $skipped_lines = 0;
        $file_coverage = [];
        $total_function_count = count(file($file_path));
        $current_function_number = 0;
        if ($fh = fopen($file_path, 'r')) {
            while (!feof($fh)) {
                $line = fgets($fh);
                $current_function_number++;
                try {
                    if (strpos($line, '|') !== false) {
                        $function_entry = explode('|', $line);
                        $function_name = $function_entry[0];
                        $file_name = trim($function_entry[1]);
                        if (strlen($line) >= strlen($original_prefix)) {
                            if (substr($line, 0, strlen($original_prefix)) === $original_prefix) {
                                if (strlen($original_prefix) > 0) {
                                    $file_name = $this->replace_first($original_prefix, $new_prefix, $file_name);
                                }
                                else {
                                    $file_name = $new_prefix.$file_name;
                                }
                            }
                        }
                        $covered_lines_array = $this->get_function_lines($file_name, $function_name);
                        if ($covered_lines_array === null) {
                            $data['error_messages'][] = "Could not find {$function_name} in {$file_name}";
                            continue;
                        }
                        foreach ($covered_lines_array as $linenumber => $covered) {
                            $file_coverage[$file_name][$linenumber] = $covered;
                        }
                    }
                }
                catch (\Exception $e) {
                    $data['error_messages'][] = $e->getMessage();
                    $skipped_lines++;
                }
            }
            fclose($fh);
        }
        $info = $this->add_coverage_to_db($fk_software_version_id, $test_name, $file_coverage);
        $info['skipped_lines'] = $skipped_lines;
        return $info;
    }

    protected function get_function_lines($file_name, $function_name) {
        $traverser = new NodeTraverser;
        $visitor = new FunctionLineVisitor($file_name, $function_name);
        $traverser->addVisitor($visitor);
        $parser = (new ParserFactory)->create(ParserFactory::PREFER_PHP5);
        try {
            $code = file_get_contents($file_name);
            $ast = $parser->parse($code);
            $traverser->traverse($ast);
            if (isset($visitor->covered_lines)) {
                return $visitor->covered_lines;
            }
        } catch (Error $error) {
            echo "Parse error at ({$file_name}): {$error->getMessage()}\n";
            //Continue debloating rest of the files and skip the file with parsing errors
            //return;
        }
        return null;
    }

    protected function add_coverage_to_db($fk_software_version_id, $test_name, $file_coverage) {
        $added_files = 0;
        $added_lines = 0;
        // Add a new test
        $this->load->model('Test_model');
        $this->load->model('Software_version_model');
        $this->load->model('Covered_file_model');
        $this->load->model('Covered_line_model');
        $software_id = $this->Software_version_model->get_software_version($fk_software_version_id)['fk_software_id'];
        $params = array(
            'test_name' => $test_name,
            'test_group' => $test_name,
            'test_date' => date('Y-m-d H:i:s'),
            'fk_software_id' => $software_id,
            'fk_software_version_id' => $fk_software_version_id,
        );
        $test_id = $this->Test_model->add_test($params);
        // Add covered files
        foreach ($file_coverage as $file_name => $lines) {
            $entries = [];
            $params = array(
                'fk_test_id' => $test_id,
                'file_name' => $file_name,
            );
            $covered_file_id = $this->Covered_file_model->add_covered_file($params);
            $added_files++;
            foreach ($lines as $line_number => $value) {
                // Add covered lines
                $params = array(
                    'fk_file_id' => $covered_file_id,
                    'line_number' => $line_number,
                    'run' => $value,
                );
                $entries[] = $params;
                $added_lines++;
            }
            $covered_line_id = $this->Covered_line_model->add_batch_covered_lines($entries);
        }
        return array(
            'added_files' => $added_files,
            'added_lines' => $added_lines,
        );
    }

    /*
     * Deleting software
     */
    function remove($id)
    {
        $software = $this->Software_model->get_software($id);

        // check if the software exists before trying to delete it
        if(isset($software['id']))
        {
            $this->Software_model->delete_software($id);
            redirect('software/index');
        }
        else
            show_error('The software you are trying to delete does not exist.');
    }
    
}

class FunctionLineVisitor extends NodeVisitorAbstract {
    private string $file_name;
    private string $function_name;
    private string $class_name;
    public array $covered_lines;
    public array $skipped_lines;

    public function __construct($file_name, $function_name) {
        $this->file_name = $file_name;
        $this->function_name = $function_name;
        if (strpos($this->function_name, '\\') !== false) {
            $this->class_name = explode('\\', $this->function_name)[0];
            $this->function_name = explode('\\', $this->function_name)[1];
        }
    }

    public function enterNode(Node $node) {
        if (isset($this->class_name)) {
            if (!isset($this->current_class)) {
                if ($node instanceof Node\Stmt\ClassLike) {
                    $this->current_class = $node->name;
                }
            }
            if ($node instanceof Node\Stmt\ClassMethod && strcasecmp($this->class_name, $this->current_class) === 0) {
                if (strcasecmp($node->name, $this->function_name) === 0) {
                    $this->add_line_coverage($node->getStartLine(), $node->getEndLine());
                }
            }
        }
        elseif ($node instanceof Node\Stmt\Function_ && strcasecmp($node->name, $this->function_name) === 0) {
            $this->add_line_coverage($node->getStartLine(), $node->getEndLine());
        }
        elseif ($this->function_name === 'main') {
            // Adding coverage for non-function instructions when function name is marked as "main"
            if (!$node instanceof Node\Stmt\ClassLike && !$node instanceof Node\Stmt\ClassMethod && !$node instanceof Node\Stmt\Property && !$node instanceof Node\Stmt\StaticVar && !$node instanceof Node\FunctionLike) {
                $this->add_line_coverage($node->getStartLine(), $node->getEndLine());
            }
            elseif ($node instanceof Node\Stmt\ClassLike || $node instanceof Node\FunctionLike) {
                $this->add_line_coverage($node->getStartLine(), $node->getStartLine());
            }
        }
    }

    protected function add_line_coverage(int $startline, int $endline) {
        for ($i = $startline; $i <= $endline; $i++) {
            $this->covered_lines[$i] = true;
        }
    }
}